어떤 확률의 곱을 계산할 때 곱할 각 확률들을 로그로 취하여 값을 더하면,
컴퓨터로 제한된 언더플로우의 문제를 다소 해결할 수 있다.


인덱스와 신호를 통해 확정적으로 들어갈 수 있겠다.
n + m C n <- 나올 수 있는 경우의 수
combination을 구현해야 하기 때문에!
2 2 3
--oo
-o-o
-oo-
o--o
o-o-
oo--

-

limit이 10억인데, 10억을 넘어가는 수는 사실상 필요 없다.
이를 감안해서, 계산이 불가능한 너무 큰 것들을 처리해버리면,
용량이 더 큰 자료형을 사용할 필요가 없다.
자료형의 전체를 구현하는 것은 편하지만
내가 필요한 값의 범위만 생각해서 구현하는 것은 영리하다.

skip만큼 넘어가서 원하는 것만 출력.

KLIS
맨 마지막에 나오는 LIS는 무조건 첫번째
같은 수가 중복되지 않으므로.

KLIS를 구해서 뒤에서부터 k번째 조건에 맞는 수를 탐색하면 끝.

1357
1358
1367
1368
시작 인덱스보다 뒤에 있는 것들의 수는 무조건 더해지면서 빠질 수밖에 없고,
이는 적어도 제곱번보다 작아질 수밖에 없다.
거의 n에 가까울 듯
큰 수부터 빼주려면 앞에서부터 빼오는게 맞을 듯.

3 1 4 2 6 5 8 7
1 1 2 2 3 3 4 4
0 0 2 1 4 4 6 6
나의 맥시멈과 나보다 앞에 있는 것의 개수
1 2 5 7
1 2 5 8
1 2 6 7
1 2 6 8
가능한데 직관적이지 못해

앞에서부터 이미 간직하고 있는게 더 편할 듯
10 9 11 8 7
무조건 포함되는 것은 아님
12 9 8 11 7 완전하게 범위가 나눠지는게 아니기 때문에 분할 ㄴㄴ

포함되는 수가 많을 수록 곱하기 뻥튀기라는 것.

순차 탐색하기 위해 어떤 정보를 갖고 있어야 하지???????

2 1 4 3 6 5 8 7

1 3 4
2 3 4
3 5 6
4 5 6
5 7 8
6 7 8
7
8

2가 먼저 나오려면 1로부터 나오는 가장 많은 수 k를 파악.

1~10만개의 LIS를 담는 배열
